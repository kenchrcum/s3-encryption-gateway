package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"regexp"
	"strings"
	"syscall"
	"time"

	"github.com/sirupsen/logrus"

	"github.com/kenneth/s3-encryption-gateway/test"
)

var gatewayProcess *os.Process
var garageProcess *os.Process // Keep track of garage process
var garageDir string          // Keep track of garage data dir

func main() {
	var (
		gatewayURL    = flag.String("gateway-url", "http://localhost:18080", "S3 Encryption Gateway URL")
		testType      = flag.String("test-type", "both", "Test type: range, multipart, or both")
		duration      = flag.Duration("duration", 30*time.Second, "Test duration")
		workers       = flag.Int("workers", 5, "Number of worker goroutines")
		qps           = flag.Int("qps", 25, "Queries per second per worker")
		objectSize    = flag.Int64("object-size", 50*1024*1024, "Object size in bytes (50MB default)")
		chunkSize     = flag.Int64("chunk-size", 64*1024, "Encryption chunk size (64KB default)")
		partSize      = flag.Int64("part-size", 10*1024*1024, "Multipart part size (10MB default)")
		baselineDir   = flag.String("baseline-dir", "testdata/baselines", "Directory for baseline files")
		threshold     = flag.Float64("threshold", 10.0, "Regression threshold percentage")
		prometheusURL    = flag.String("prometheus-url", "", "Prometheus URL for additional metrics")
		verbose          = flag.Bool("verbose", false, "Enable verbose logging")
		updateBaseline   = flag.Bool("update-baseline", false, "Update baseline files instead of checking regression")
		manageMinIO      = flag.Bool("manage-minio", false, "Automatically start/stop MinIO test environment")
		manageGarage     = flag.Bool("manage-garage", false, "Automatically start/stop Garage test environment")
		minioComposeFile = flag.String("minio-compose", "docker-compose.yml", "Path to MinIO docker-compose file")
		gatewayConfig    = flag.String("gateway-config", "test/gateway-config-minio.yaml", "Path to gateway config file")
	)

	flag.Parse()

	// Setup logging (before MinIO/Garage management)
	logger := logrus.New()
	if *verbose {
		logger.SetLevel(logrus.DebugLevel)
	} else {
		logger.SetLevel(logrus.InfoLevel)
	}

	// Validate flags
	if *manageMinIO && *manageGarage {
		log.Fatal("Cannot manage both MinIO and Garage at the same time")
	}

	// When managing environment, automatically adjust gateway URL
	if (*manageMinIO || *manageGarage) && *gatewayURL == "http://localhost:8080" {
		*gatewayURL = "http://localhost:18080" // Matches the port in gateway-config-minio.yaml (we might reuse or override port)
		logger.Info("Automatically adjusted gateway URL for backend management")
	}
	
	// Set valid gateway config for Garage if not specified
	if *manageGarage && *gatewayConfig == "test/gateway-config-minio.yaml" {
		// We will creating a temporary config or use env vars to override
		logger.Info("Using default minio config but will override backend settings via env vars for Garage")
	}

	// Set up signal handling for graceful cleanup
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	// Env vars for gateway
	gatewayEnv := make(map[string]string)

	// Manage MinIO and Gateway environment if requested
	if *manageMinIO {
		// Start MinIO first
		if err := startMinIOEnvironment(*minioComposeFile, logger); err != nil {
			log.Fatalf("Failed to start MinIO environment: %v", err)
		}
		
		// Setup cleanup for MinIO
		defer func() {
			logger.Info("ðŸ§¹ Cleaning up MinIO...")
			stopMinIOEnvironment(*minioComposeFile, logger)
		}()
	} else if *manageGarage {
		// Start Garage first
		accessKey, secretKey, err := startGarageEnvironment(logger)
		if err != nil {
			log.Fatalf("Failed to start Garage environment: %v", err)
		}
		
		// Setup cleanup for Garage
		defer func() {
			logger.Info("ðŸ§¹ Cleaning up Garage...")
			stopGarageEnvironment(logger)
		}()
		
		// Set gateway env vars
		gatewayEnv["BACKEND_ENDPOINT"] = "http://127.0.0.1:3900"
		gatewayEnv["BACKEND_REGION"] = "garage"
		gatewayEnv["BACKEND_ACCESS_KEY"] = accessKey
		gatewayEnv["BACKEND_SECRET_KEY"] = secretKey
		gatewayEnv["BACKEND_PROVIDER"] = "s3"
		gatewayEnv["BACKEND_USE_PATH_STYLE"] = "true"
	}

	if *manageMinIO || *manageGarage {
		// Start Gateway
		if err := startGateway(*gatewayConfig, gatewayEnv, logger); err != nil {
			log.Fatalf("Failed to start gateway: %v", err)
		}
		
		// Setup cleanup for Gateway
		defer func() {
			logger.Info("ðŸ§¹ Cleaning up Gateway...")
			stopGateway(logger)
		}()
		
		// Handle signals logic
		go func() {
			<-sigChan
			logger.Info("ðŸ›‘ Received interrupt signal, cleaning up...")
			stopGateway(logger)
			if *manageMinIO {
				stopMinIOEnvironment(*minioComposeFile, logger)
			}
			if *manageGarage {
				stopGarageEnvironment(logger)
			}
			os.Exit(1)
		}()
		
		// Note: defer cleanups execute in LIFO order
	}

	// Ensure baseline directory exists
	if err := os.MkdirAll(*baselineDir, 0755); err != nil {
		log.Fatalf("Failed to create baseline directory: %v", err)
	}

	fmt.Println("=== S3 Encryption Gateway Load Test Runner ===")
	fmt.Printf("Gateway URL: %s\n", *gatewayURL)
	fmt.Printf("Test Type: %s\n", *testType)
	fmt.Printf("Duration: %v\n", *duration)
	fmt.Printf("Workers: %d\n", *workers)
	fmt.Printf("QPS per Worker: %d\n", *qps)
	fmt.Printf("Regression Threshold: %.1f%%\n", *threshold)
	if *prometheusURL != "" {
		fmt.Printf("Prometheus URL: %s\n", *prometheusURL)
	}
	fmt.Println()

	var exitCode int
	startTime := time.Now()

	// Run range tests
	if *testType == "range" || *testType == "both" {
		fmt.Println("--- Running Range Load Test ---")
		if err := runRangeTest(*gatewayURL, *workers, *duration, *qps, *objectSize, *chunkSize,
			*baselineDir, *threshold, *prometheusURL, *updateBaseline, logger); err != nil {
			log.Printf("Range test failed: %v", err)
			exitCode = 1
		}
		fmt.Println()
	}

	// Run multipart tests
	if *testType == "multipart" || *testType == "both" {
		fmt.Println("--- Running Multipart Load Test ---")
		if err := runMultipartTest(*gatewayURL, *workers, *duration, *qps, *objectSize, *partSize,
			*baselineDir, *threshold, *prometheusURL, *updateBaseline, logger); err != nil {
			log.Printf("Multipart test failed: %v", err)
			exitCode = 1
		}
		fmt.Println()
	}

	totalDuration := time.Since(startTime)
	fmt.Printf("=== Load Tests Complete (Total Time: %v) ===\n", totalDuration)

	if exitCode != 0 {
		fmt.Println("âŒ Some tests failed or regressions detected")
		os.Exit(exitCode)
	} else {
		fmt.Println("âœ… All tests passed")
	}
}

// ... (keep existing runRangeTest, runMultipartTest) ...

// startGarageEnvironment starts a local Garage server using the binary.
// Returns access key and secret key.
func startGarageEnvironment(logger *logrus.Logger) (string, string, error) {
	logger.Info("Starting Garage test environment...")
	
	// Create temp dirs
	tmpDir, err := os.MkdirTemp("", "garage-loadtest-*")
	if err != nil {
		return "", "", fmt.Errorf("failed to create temp dir: %w", err)
	}
	garageDir = tmpDir
	dataDir := filepath.Join(tmpDir, "data")
	configDir := filepath.Join(tmpDir, "meta")
	os.MkdirAll(dataDir, 0755)
	os.MkdirAll(configDir, 0755)

	// Create config.toml
	configFile := filepath.Join(tmpDir, "config.toml")
	configContent := fmt.Sprintf(`
metadata_dir = "%s"
data_dir = "%s"
db_engine = "sqlite"

[rpc]
bind_addr = "127.0.0.1:3901"

[s3_api]
s3_region = "garage"
api_bind_addr = "127.0.0.1:3900"

[s3_web]
bind_addr = "127.0.0.1:3902"
root_domain = ".web.garage"
index = "index.html"
`, configDir, dataDir)

	if err := os.WriteFile(configFile, []byte(configContent), 0644); err != nil {
		return "", "", fmt.Errorf("failed to write config file: %w", err)
	}

	// Start Garage
	cmd := exec.Command("garage", "server", "-c", configFile)
	if err := cmd.Start(); err != nil {
		return "", "", fmt.Errorf("failed to start garage server: %w", err)
	}
	garageProcess = cmd.Process

	// Wait for Garage to be ready (RPC)
	time.Sleep(2 * time.Second)

	// Configure Garage
	// 1. Get Node ID
	nodeIDCmd := exec.Command("garage", "node", "id", "-c", configFile)
	out, err := nodeIDCmd.CombinedOutput()
	if err != nil {
		return "", "", fmt.Errorf("failed to get node id: %w", err)
	}
	// Note: 'garage node id' output might be cluttered if run directly, but usually clean on stdout if successful
	// Let's assume the last line is the ID if there are logs
	lines := strings.Split(strings.TrimSpace(string(out)), "\n")
	nodeID := lines[len(lines)-1]
    // Filter out potential log lines
    if len(nodeID) < 10 { // weak heuristic
       // Try parsing
       re := regexp.MustCompile(`[a-f0-9]{64}`)
       match := re.FindString(string(out))
       if match != "" {
           nodeID = match
       }
    }

	// 2. Assign Layout
	layoutCmd := exec.Command("garage", "layout", "assign", "-z", "dc1", "-c", "1", nodeID, "-c", configFile)
	if out, err := layoutCmd.CombinedOutput(); err != nil {
		return "", "", fmt.Errorf("failed to assign layout: %w, output: %s", err, string(out))
	}

	// 3. Apply Layout
	applyCmd := exec.Command("garage", "layout", "apply", "--version", "1", "-c", configFile)
	if out, err := applyCmd.CombinedOutput(); err != nil {
		return "", "", fmt.Errorf("failed to apply layout: %w, output: %s", err, string(out))
	}

	// 4. Create Key
	keyName := "loadtest-key"
	keyCmd := exec.Command("garage", "key", "create", keyName, "-c", configFile)
	out, err = keyCmd.CombinedOutput()
	if err != nil {
		return "", "", fmt.Errorf("failed to create key: %w, output: %s", err, string(out))
	}
	
	outputStr := string(out)
	reAccess := regexp.MustCompile(`Key ID:\s+(\S+)`)
	reSecret := regexp.MustCompile(`Secret Key:\s+(\S+)`)
	
	accessMatch := reAccess.FindStringSubmatch(outputStr)
	secretMatch := reSecret.FindStringSubmatch(outputStr)
	
	if len(accessMatch) < 2 || len(secretMatch) < 2 {
		return "", "", fmt.Errorf("failed to parse key from output: %s", outputStr)
	}
	accessKey := accessMatch[1]
	secretKey := secretMatch[1]

	// 5. Create Bucket and Allow Key
    bucketName := "test-bucket" // Must match what load test expects (usually expects 'test-bucket')
    
    bucketCmd := exec.Command("garage", "bucket", "create", bucketName, "-c", configFile)
    if out, err := bucketCmd.CombinedOutput(); err != nil {
        return "", "", fmt.Errorf("failed to create bucket: %w, output: %s", err, string(out))
    }
    
    allowCmd := exec.Command("garage", "bucket", "allow", bucketName, "--read", "--write", "--key", keyName, "-c", configFile)
    if out, err := allowCmd.CombinedOutput(); err != nil {
        return "", "", fmt.Errorf("failed to allow key: %w, output: %s", err, string(out))
    }
    
    logger.Info("âœ… Garage test environment is ready")
    return accessKey, secretKey, nil
}

func stopGarageEnvironment(logger *logrus.Logger) {
    if garageProcess != nil {
        garageProcess.Kill()
        garageProcess = nil
    }
    if garageDir != "" {
        os.RemoveAll(garageDir)
        garageDir = ""
    }
}


// ... (keep startMinIOEnvironment, etc) ...

// startGateway starts the S3 Encryption Gateway with the specified config.
func startGateway(configFile string, envVars map[string]string, logger *logrus.Logger) error {
	logger.WithField("config_file", configFile).Info("Starting S3 Encryption Gateway...")

	// Build the gateway binary path (assume bin/ relative to project root)
	// Since the shell script runs from test/, we assume project root is ..
	projectRoot := ".."
    // If running from project root (go run cmd/loadtest/main.go), project root is "."
    // We should detect where we are running from.
    // If 'test/' directory exists in current dir, we are in project root.
    if _, err := os.Stat("test"); err == nil {
        projectRoot = "."
    }

	gatewayBinary := filepath.Join(projectRoot, "bin", "s3-encryption-gateway")

	// Convert to absolute path
	if absPath, err := filepath.Abs(gatewayBinary); err == nil {
		gatewayBinary = absPath
	}

	if _, err := os.Stat(gatewayBinary); os.IsNotExist(err) {
		// Try to build it first
		logger.Info("Gateway binary not found, building it...")
		buildCmd := exec.Command("go", "build", "-o", "bin/s3-encryption-gateway", "./cmd/server")
		buildCmd.Dir = projectRoot // Build from project root
		if output, err := buildCmd.CombinedOutput(); err != nil {
			return fmt.Errorf("failed to build gateway: %v\nOutput: %s", err, string(output))
		}
		logger.Info("Gateway binary built successfully")
	}

	// Check if config file exists (relative to project root where gateway will run)
	configPath := filepath.Join(projectRoot, configFile)
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		logger.WithError(err).WithField("config_path", configPath).Error("Config file not found")
		return fmt.Errorf("gateway config file not found: %s", configPath)
	}
	logger.WithField("config_path", configPath).Debug("Config file found")

	// Start the gateway
	logger.Info("Starting gateway process...")
	cmd := exec.Command(gatewayBinary)
	cmd.Env = os.Environ()
    cmd.Env = append(cmd.Env, "CONFIG_PATH="+configFile)
    
    // Append extra env vars
    for k, v := range envVars {
        cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", k, v))
    }
    
	cmd.Dir = projectRoot // Run from project root
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start gateway: %v", err)
	}

	// Store the process for cleanup
	gatewayProcess = cmd.Process

	// Wait for gateway to be ready
	logger.Info("Waiting for gateway to become ready...")
	if err := waitForGatewayReady(logger); err != nil {
		// Kill the process if it fails to start
		gatewayProcess.Kill()
		gatewayProcess.Wait()
		gatewayProcess = nil
		return fmt.Errorf("gateway failed to become ready: %v", err)
	}

	// Create test bucket directly in MinIO (only if using MinIO)
    // Garage bucket creation is handled in startGarageEnvironment
    // If we are using MinIO check that
    // But startGateway doesn't know. 
    // We can just try creating bucket in MinIO as "best effort" via SDK if needed?
    // Actually, createTestBucketDirectlyInMinIO uses 'aws' cli against localhost:9000.
    // If Garage is running on 3900, that call will fail or hit nothing (unless Garage is on 9000).
    // Garage test uses 3900.
    // So we should skip createTestBucketDirectlyInMinIO if generic S3.
    // However, existing behavior calls it always.
    
    // Minimal change:
    // Only call createTestBucketDirectlyInMinIO if env doesn't have BACKEND_ENDPOINT override for garage?
    // or just let it fail silently (it logs warning).
    
	if _, ok := envVars["BACKEND_ENDPOINT"]; !ok {
         // Only if not overridden, assume MinIO default
        logger.Info("Creating test bucket directly in MinIO...")
        if err := createTestBucketDirectlyInMinIO(logger); err != nil {
            logger.WithError(err).Warn("Failed to create test bucket in MinIO")
        }
    }

	logger.Info("âœ… S3 Encryption Gateway is ready")
	return nil
}
